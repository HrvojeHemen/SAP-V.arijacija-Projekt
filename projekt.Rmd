---
title: 'Projekt iz kolegija Statistička analiza podataka: Analiza filmova na IMDb-u'
author: "V.arijacija"
date: '13 01 2022 '
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

imdb <- read.csv(file = 'IMDB.csv')
library(tidyr)
library(tidyverse)
library(modeest)
```

# Uvod

U ovom projektu analiziramo skup podataka o filmovima sa stranice IMDb. Podatke, koji se nalaze u CSV datoteci IMDB.csv, učitali smo u varijablu imdb. Pogledajmo kako izgleda naš set podataka - koje su mu dimenzije, kako se zovu njegove varijable i kojeg su tipa podataka.

```{r}
# Dimenzije tablice podataka

cat("No. of rows:", nrow(imdb), '\n')
cat("No. of columns:", ncol(imdb), '\n')

# Imena i tipovi varijabli

cat("\nVariables and their types:\n\n")
sapply(imdb, class)
```

Naš set podataka ima 5043 redaka (unosa) i 28 stupaca (varijabli).

Varijable su sljedeće:

  - movie_title - naslov filma
  - director_name - ime redatlja filma
  - title_year - godina premijere filma
  - actor_1_name - ime glumca br. 1
  - actor_2_name - ime glumca br. 2
  - actor_3_name - ime glumca br. 3
  - genres - žanrovi kojima film pripada odvojeni znakom '|'
  - content_rating - MPAA oznaka filma
  - plot_keywords - ključne riječi koje opisuju radnju filma odvojene znakom '|'
  - duration - trajanje filma u minutama
  - language - jezik filma
  - country - država u kojoj je produciran film
  - budget - budžet filma u dolarima
  - gross - zarada filma u dolarima
  - color - informacija je li film crno-bijeli ili u boji
  - aspect_ratio - format filma
  - facenumber_in_poster - broj glumaca koji su prikazani na posteru filma
  - movie_imdb_link - poveznica na IMDB stranicu filma
  - imdb_score - IMDB-ova ocjena filma
  - num_critic_for_reviews - broj filmskih kritičara koji su recenzirali film
  - num_voted_users - broj korisnika IMDB-a koji su glasali za film
  - num_user_for_reviews - broj korisnika IMDB-a koji su recenzirali film
  - movie_facebook_likes - ukupan broj Facebook lajkova koje je film dobio
  - director_facebook_likes - broj Facebook lajkova na Facebook stranici direktora
  - actor_1_facebook_likes - broj Facebook lajkova na Facebook stranici glumca br. 1
  - actor_2_facebook_likes - broj Facebook lajkova na Facebook stranici glumca br. 2
  - actor_3_facebook_likes - broj Facebook lajkova na Facebook stranici glumca br. 3
  - cast_total_facebook_likes - ukupan broj Facebook lajkova sa Facebook stranica svih glumaca iz postave filma

Uočavamo da metrički podaci čine većinu našeg skupa podataka, npr. varijable duration, budget, gross i sl. Neke od kategorijskih varijabli su movie_title, director_name, genres itd. Varijabla movie_imdb_link za nas nema značaj pa ćemo je maknuti iz našeg seta podataka.

```{r}
# Izbacivanje "movie_imdb_link"

imdb <- imdb[-c(18)]
dim(imdb)
```


Pogledajmo koliki postotak nepostojećih vrijednosti imaju preostale varijable.

```{r}
# NA vrijednosti

for (variable in names(imdb)) {
  nas = sum(is.na(imdb[variable]))
  p = round(nas / nrow(imdb) * 100, 2)

  cat(variable, ":", nas, '(', p, '%)\n')
}
```

Većina stupaca sadrži jako malo nepostojećih vrijednosti osim stupca sa zaradom filmova koji sadrži 884 nepostojeće vrijednosti što je gotovo 20% ukupnog broja filmova te zaključci koje bismo donijeli na temelju tih podataka ne bi najbolje prikazivali stvarnu sliku.



# Deskriptivna statistika

## Kategorijske varijable

### Varijabla genres

Za varijablu genres već smo ranije utvrdili da nema nedostajućih vrijednosti, stoga ne moramo paziti na te vrijednosti pri radu s podacima. 

Prvo moramo svaki redak razdvojiti na više njih ovisno o njegovom broju žanrova.

```{r}
# Separacija žanrova

imdb_sep_bygenres <- separate_rows(imdb, genres, sep = "\\|")
```

Najprije pogledajmo koliko je različitih žanrova te koji je najzastupljeniji, a koji je najmanje zastupljen.

```{r}
occurences = imdb_sep_bygenres$genres
occurences_df = as.data.frame(table(occurences))
colnames(occurences_df) = c('genre', 'occurences')
occurences_df = occurences_df[order(occurences_df$occurences, decreasing = TRUE), ]

cat("No. of Genres:", nrow(occurences_df))


par(mar=c(7.5, 4.1, 4.1, 2.1), font.axis = 2, font.lab =  2)

# Stupčasti dijagram

barplot(height = occurences_df$occurences,
        names.arg = occurences_df$genre,
        main = "No. of Films by Genre",
        ylab = "No. of Films",
        las = 2, col = "Lightblue")
```

U našoj tablici podataka pojavljuje se ukupno 26 različitih žanrova. Žanr s najviše snimljenih filmova jest "Drama". Također, primijećujemo da žanrovi "Film-Noir", Short", "News", "Reality-TV" i "Game-Show" jako mali broj snimljenih filmova u odnosu na ostatak žanrova te zato odbacujemo ove žanrove iz daljnje analize zbog premalog broja podataka.

```{r}
# Izbacivanje vrijednosti "Film-Noir", "Short", "News", "Reality-TV" i "Game-Show"

tbd <- c('Film-Noir', 'Short', 'News', 'Reality-TV', 'Game-Show')
genres_edited <- imdb_sep_bygenres[!(imdb_sep_bygenres$genres %in% tbd), ]
```


### Varijabla plot_keywords

Za varijablu plot_keywords već smo ranije utvrdili da ima 153 nedostajuće vrijednosti, stoga moramo pripaziti da te vrijednosti isključimo iz analize ključnih riječi.

Prvo moramo svaki redak razdvojiti na više njih ovisno o njegovom broju ključnih riječi.

```{r}
# Separacija ključnih riječi

imdb_sep_bykeywords <- separate_rows(imdb[imdb$plot_keywords != '', ], plot_keywords, sep = "\\|")
```

Najprije pogledajmo koliko je različitih ključnih riječi te koji su najzastupljenije.

```{r}
occurences = imdb_sep_bykeywords$plot_keywords
occurences_df = as.data.frame(table(occurences))
colnames(occurences_df) = c('keyword', 'occurences')
occurences_df = occurences_df[order(occurences_df$occurences, decreasing = TRUE), ]

cat("No. of rows:", nrow(occurences_df))


par(mar=c(7.5, 4.1, 4.1, 2.1), font.axis = 2, font.lab =  2)

# Stupčasti dijagram

barplot(height = occurences_df[1:20, "occurences"],
        names.arg = occurences_df[1:20, "keyword"],
        main = "No. of Mentions of a Keyword",
        ylab = "No. of Mentions",
        las = 2, col = "Lightblue")
```

U našoj tablici podataka pojavljuje se ukupno 8086 različitih ključnih riječi. Tri najzastupljenije ključne riječi su "love", "friend" i "murder", što i ima smisla ako se prisjetimo da je najzastupljeniji žanr filmova drama.


### Varijabla country

Pogledajmo koliko je različitih država te u kojoj je državi producirano najviše filmova, pritom zanemarujemo nedostajuće vrijednosti.

```{r}
occurences = imdb[!is.na(imdb$country), "country"]
occurences_df = as.data.frame(table(occurences))
colnames(occurences_df) = c('country', 'occurences')
occurences_df = occurences_df[order(occurences_df$occurences, decreasing = TRUE), ]

cat("No. of rows:", nrow(occurences_df))


par(mar=c(7.5, 4.1, 4.1, 2.1), font.axis = 2, font.lab =  2)

# Stupčasti dijagram

barplot(height = occurences_df[1:10, "occurences"],
        names.arg = occurences_df[1:10, "country"],
        main = "No. of Films per Country",
        ylab = "No. of Films",
        las = 2, col = "Lightblue")
```

Ukupno je 66 različitih država, pri čemu je SAD daleko najzastupljeniji, što je razumljivo s obzirom na razvijenost filmske industrije u SAD-u.

Pogledajmo koliko je točno filmova snimljeno u SAD-u.

```{r}
n = occurences_df[occurences_df$country == 'USA', 'occurences']
p = n / nrow(imdb) * 100

cat("No. of films produced in USA:", n, "(", p, "%)")
```

Kako vrijednost "USA" sačinjava i više od 75% svih podataka, ova nam varijabla ne daje toliku raznolikost podataka. Zato ćemo u daljnjoj analizi filmove razdvajati na američke i neameričke.


## Metričke varijable

### Varijabla title_year

Pogledajmo kako se ponaša varijabla title_year.

```{r}
summary(imdb$title_year)
```

Najstariji zabilježeni film je iz 1916. godine, a "najmlađi" je iz 2016. "Mlađa" polovica filmova imala je premijeru u periodu između 2005. i 2016. godine, dok je interval za drugu polovicu filmova dug gotovo 90 godina. To zapažanje ima smisla s obzirom na razvoj filmske industrije od samih početaka pa sve do danas.

Također, možemo opaziti da je medijan veći od aritmetičke sredine iz čega možemo pretpostaviti da je distribucija lijevo (negativno) zakrivljena. Tu tvrdnju možemo potvrditi i histogramom.

```{r}
par(mar=c(7.5, 4.1, 4.1, 2.1), font.axis = 2, font.lab =  2)

# Histogram

hist(imdb$title_year,
     main="Title Year Histogram",
     xlab="Year",
     ylab='Frequency',
     breaks = 20, col="lightblue")
```


### Varijabla duration

Prvo ćemo pogledati histogram i pravokutni dijagram.

```{r}
par(mar=c(7.5, 4.1, 4.1, 2.1), font.axis = 2, font.lab =  2)

# Histogram

hist(imdb$duration,
     breaks=20,
     main="Film's duration in minutes",
     xlab="Duration (min)",
     ylab='Frequency',
     col = 'lightblue')

# Pravokutni dijagram

boxplot(imdb$duration,
        main="Box and whisker plot for duration",
        ylab="Duration (min)")


```

Možemo vidjeti kako ovaj skup podataka i nije baš najzahvalniji za prikaz pomoću stupčastog dijagrama jer je rang ovog skupa podataka dosta velik te imamo jako puno stršećih vrijednosti. Međutim možemo pretpostaviti kako ova distribucija nalikuje na multimodalnu.

```{r}
# Rang

cat("Rang:", max(imdb[(!is.na(imdb$duration)), 'duration']) - min(imdb[(!is.na(imdb$duration)), 'duration']))
```

Pogledajmo sada mjere centra.
```{r}

# Medijan
cat("Median:", median(imdb[(!is.na(imdb$duration)), 'duration']),"\n")

# Podrezana aritmetička sredina s uklanjanjem po 10% najmanjih i najvecih podataka
cat("10% trimmed mean:", mean(imdb[(!is.na(imdb$duration)), 'duration'], trim=0.1), "\n")

# Aritmeticka sredina
cat("Mean:", mean(imdb[(!is.na(imdb$duration)), 'duration']),"\n")

# Mod
require(modeest)
cat("Mod:", mfv(imdb[(!is.na(imdb$duration)), 'duration']),"\n")

```
Zbog velikog broja stršećih vrijednosti najbolji pokazatelj centra je mod koji je robusan i neosjetljiv na ekstreme kojih u ovom skupu podataka ima jako mnogo.

Nadalje pogledajmo mjere rasipanja.

```{r}
# IQR
cat("IQR:", IQR(imdb[(!is.na(imdb$duration)), 'duration']),"\n")

# Varijanca
cat("Variance:", var(imdb[(!is.na(imdb$duration)), 'duration']),"\n")

# Standardna devijacija
cat("Standard deviation:", sd(imdb[(!is.na(imdb$duration)), 'duration']),"\n")

# Koeficijent varijacije
cat("Variation coefficient:", sd(imdb[(!is.na(imdb$duration)), 'duration'])/mean(imdb[(!is.na(imdb$duration)), 'duration']),"\n")

```

Ovdje je zanimljivo pogledati interkvartilni rang koji je izuzetno mali u odnosu na rang cijelog skupa podataka. Iznosi tek 25 što je i očekivano
s obzirom da većina filmova traje od otprlike 90 do 120 minuta. Upravo odavdje dolazi velik broj stršećih vrijednosti.

Pronađimo još najkraći i najdulji film te njihova trajanja.

```{r}
# Uređivanje naslova filma

for (i in 1:nrow(imdb)) {
  row = imdb[i, 'movie_title']
  imdb[i, 'movie_title'] <- str_split(row, 'Â')[[1]][1]
}

# Najkraći i najdulji film

lenmin = min(imdb[(!is.na(imdb$duration)), 'duration'])
lenmax = max(imdb[(!is.na(imdb$duration)), 'duration'])

moviemin = imdb[(!is.na(imdb$duration)) & (imdb$duration == lenmin), 'movie_title']
moviemax = imdb[(!is.na(imdb$duration)) & (imdb$duration == lenmax), 'movie_title']

cat('The shortest movie in dataset:\n', moviemin, '\nlasts:', lenmin, 'minutes\n')
cat('\nThe longest movie in dataset:\n', moviemax, '\nlasts:', lenmax, 'minutes\n')
```

Primjećujemo da dva filma dijele titulu najkraćeg filma: "Shaun the Sheep" i "The Touch", a najdulji film je "Trapped" koji traje više od 8 sati (vjerojatno je riječ o mini-seriji).


### Varijabla budget

Varijabla budget ima 492 nedostajuće vrijednosti pa moramo pripraziti da ih ne uključimo u daljnju analizu.

Prvo ćemo pogledati histogram i pravokutni dijagram.

```{r}
# Histogram

hist(imdb$budget,
     breaks=20,
     main="Film's budget in dollars",
     xlab="Budget (dollars)",
     ylab='Frequency',
     col = 'lightblue')

# Pravokutni dijagram

boxplot(imdb$budget,
        main="Box and whisker plot for budget",
        ylab="Budget (dollars)")

```

```{r}
# Rang

cat("Rang:", max(imdb[(!is.na(imdb$budget)), 'budget']) - min(imdb[(!is.na(imdb$budget)), 'budget']))
```

Rang distribucije budžeta filmova je jako velik te imamo povelik broj stršećih vrijednosti, zbog čega ne možemo puno zaključiti iz histograma.

Pogledajmo mjere centra.
```{r}

# Medijan
cat("Median:", median(imdb[(!is.na(imdb$budget)), 'budget']),"\n")

# Podrezana aritmetička sredina s uklanjanjem po 10% najmanjih i najvecih podataka
cat("10% trimmed mean:", mean(imdb[(!is.na(imdb$budget)), 'budget'], trim=0.1), "\n")

# Aritmeticka sredina
cat("Mean:", mean(imdb[(!is.na(imdb$budget)), 'budget']),"\n")

# Mod
require(modeest)
cat("Mod:", mfv(imdb[(!is.na(imdb$budget)), 'budget']),"\n")

```

Uočavamo da su medijan i mod jednaki i "blizu" vrijednosti podrezane aritemtičke sredine. Dakle, distribucija bi mogla nalikovati normalnoj distribuciji.

Skalirajmo podatke prirodnim logaritmom.

```{r}
# Histogram (log)

h = hist(log(imdb$budget),
         axes = FALSE,
         main="Film's budget in dollars (log)",
         xlab="Budget (dollars)",
         ylab='Frequency',
         breaks = 20, col="lightblue")
 axis(side = 1,
     at = log(c(100, 500, 5000, 50000, 500000, 5000000, 50000000, 500000000, 5000000000, 50000000000)),
     labels = paste(c(100, 500, 5000, 50000, 500000, 5000000, 50000000, 500000000, 5000000000, 50000000000)),
     cex.axis = 0.75,
     padj = -1,
     hadj = 0.5,
     las = 1)
axis(2)
```

Sada puno bolje možemo vidjeti distribuciju budžeta. Distribucija nalikuje normalnoj, no malo je zakrivljena u lijevo.


### Varijabla gross
Prvo ćemo pogledati histogram i pravokutni dijagram.

```{r}
# Histogram

hist(imdb$gross,
     breaks=20,
     main="Film's gross in dollars",
     xlab="Gross (dollars)",
     ylab='Frequency' )

# Pravokutni dijagram

boxplot(imdb$gross,
        main="Box and whisker plot for gross",
        ylab="Gross (dollars)")

```

```{r}
# Rang

cat("Rang:", max(imdb[(!is.na(imdb$gross)), 'gross']) - min(imdb[(!is.na(imdb$gross)), 'gross']))
```

Slično kao i kod budžeta, imamo veliki rang i pozamašan broj stršećih vrijednosti.

Pogledajmo mjere centra.

```{r}

# Medijan
cat("Median:", median(imdb[(!is.na(imdb$gross)), 'gross']),"\n")

# Podrezana aritmetička sredina s uklanjanjem po 10% najmanjih i najvecih podataka
cat("10% trimmed mean:", mean(imdb[(!is.na(imdb$gross)), 'gross'], trim=0.1), "\n")

# Aritmeticka sredina
cat("Mean:", mean(imdb[(!is.na(imdb$gross)), 'gross']),"\n")

# Mod
require(modeest)
cat("Mod:", mfv(imdb[(!is.na(imdb$gross)), 'gross']),"\n")

```

Medijan i podrezana aritmetička sredina su također naoko "blizu" pa bismo mogli i ovdje skalirati podatke prirodnim logaritmom kako bismo bolje vizualizirali podatke.

```{r}

h = hist(log(imdb$gross),
         axes = FALSE,
         main="Film's gross in dollars (log)",
         xlab="Gross (dollars)",
         ylab='Frequency',
         breaks = 20, col="lightblue")
 axis(side = 1,
     at = log(c(100, 500, 5000, 50000, 500000, 5000000, 50000000, 500000000, 5000000000, 50000000000)),
     labels = paste(c(100, 500, 5000, 50000, 500000, 5000000, 50000000, 500000000, 5000000000, 50000000000)),
     cex.axis = 0.75,
     padj = -1,
     hadj = 0.5,
     las = 1)
axis(2)

```

Sada svakako bolje vidimo kako su distribuirani podaci o zaradi filmova. Vidimo da je riječ o lijevo (negativno) zakrivljenoj distribuciji.


### Varijabla imdb_score

Prethodno smo uvidjeli da varijabla imdb_score nema nedostajućih vrijednoti.

Pogledajmo prvo histogram i pravokutni dijagram.

```{r}
# Histogram

hist(imdb$imdb_score,
     breaks=20,
     main="Film's IMDB Score",
     xlab="Score",
     ylab='Frequency',
     col = 'lightblue')

# Pravokutni dijagram

boxplot(imdb$imdb_score,
        main="Box and whisker plot for IMDB Score",
        ylab="Score")


```

Pogledajmo prosječne ocjene uz pojedini žanr. Za mjeru centra koristili smo aritmetičku sredinu. 

```{r}

imdb_sep_bygenres %>% group_by(genres) %>% summarise(AVG_imdb_rating = mean(imdb_score)) -> summary.result.avg

##postavljanje podataka na barplot
data_bar <- summary.result.avg$AVG_imdb_rating
names(data_bar) <- summary.result.avg$genres

##uredjivanje margina
par(mar=c(7.5, 4.1, 4.1, 2.1), font.axis = 2, font.lab =  2)

barplot(data_bar, 
        main="Prosječna ocjena filmova za pojedine žanrove",
        ylab = "Prosječna ocjena [0-10]",
        las = 2, col="lightblue")
```

Gore dobiveni dijagram jako podsjeća na uniformnu distribuciju. Pogledajmo sada standardne devijacije za pojedini žanr.

```{r}
imdb_sep_bygenres %>% group_by(genres) %>% summarise(AVG_imdb_rating = sd(imdb_score)) -> summary.result.sd

data_bar <- summary.result.sd$AVG_imdb_rating
names(data_bar) <- summary.result.sd$genres

par(mar=c(7.5, 4.1, 4.1, 2.1), font.axis = 2, font.lab =  2)

barplot(data_bar, 
        main="Standardna devijacija ocjena filmova za pojedine žanrove",
        ylab = "Standardna devijacija",
        las = 2, col="lightblue")

```

Vidimo kako samo žanr "Biography" značajnije odstupa od drugih standardnih varijacija, no i dalje možemo pretpostaviti kako se radi o uniformnoj distribuciji.


## Varijable movie_facebook_likes, director_facebook_likes, actor_1_facebook_likes, actor_2_facebook_likes, actor_3_facebook_likes, cast_total_facebook_likes

Prethodno smo uočili da je broj lajkova koje je dobio film zabilježen za svaki unos (redak) u  tablici podataka. Isto vrijedi i za broj lajkova koje je dobila cjelokupna glumačka postava. Broj nezabilježenih unosa lajkova glavnih glumaca redom iznose: 7 (~0.14%) za prvog glumca, 13 (~0.26%) za drugog glumca te 23 (0.46%) za trećeg glumca. Najveći broj nedostajućih vrijednosti ima stupac lajkova koje je dobio redatelj - 104 (~2.12%).

Riječ je o jako malim udjelima pa možemo maknuti sve retke u kojima barem jedan od tih stupaca ima nedostajaću vrijednost.

```{r}
likesdata <- imdb[!(is.na(imdb$movie_facebook_likes)
                      | is.na(imdb$director_facebook_likes)
                      | is.na(imdb$actor_1_facebook_likes)
                      | is.na(imdb$actor_2_facebook_likes)
                      | is.na(imdb$actor_3_facebook_likes)
                      | is.na(imdb$cast_total_facebook_likes)), ]

cat('No. of entries:', nrow(likesdata), '\n')
```

Nova tablica bez nedostajućih vrijednosti ima 4797 redaka, što je oko 97% od ukupnog broja redaka stare tablice podataka. Uklonili smo gotovo nezamjetan broj redaka.

Sada kada smo uklonili nedostajuće vrijednosti, pogledajmo kako se ponašaju te varijable.

```{r}
summary(likesdata[c('movie_facebook_likes', 'director_facebook_likes', 'actor_1_facebook_likes', 'actor_2_facebook_likes', 'actor_3_facebook_likes', 'cast_total_facebook_likes')])

cat('\nIQR(Movie Facebook Likes) =', IQR(likesdata$movie_facebook_likes), '\n')
cat('sd(Movie Facebook Likes) =', sd(likesdata$movie_facebook_likes), '\n')

cat('\nIQR(Director Facebook Likes) =', IQR(likesdata$director_facebook_likes), '\n')
cat('sd(Director Facebook Likes) =', sd(likesdata$director_facebook_likes), '\n')

cat('\nIQR(Actor1 Facebook Likes) =', IQR(likesdata$actor_1_facebook_likes), '\n')
cat('sd(Actor1 Facebook Likes) =', sd(likesdata$actor_1_facebook_likes), '\n')

cat('\nIQR(Actor2 Facebook Likes) =', IQR(likesdata$actor_2_facebook_likes), '\n')
cat('sd(Actor2 Facebook Likes) =', sd(likesdata$actor_2_facebook_likes), '\n')

cat('\nIQR(Actor3 Facebook Likes) =', IQR(likesdata$actor_3_facebook_likes), '\n')
cat('sd(Actor3 Facebook Likes) =', sd(likesdata$actor_3_facebook_likes), '\n')

cat('\nIQR(Cast Total Facebook Likes) =', IQR(likesdata$cast_total_facebook_likes), '\n')
cat('sd(Cast Total Facebook Likes) =', sd(likesdata$cast_total_facebook_likes), '\n')
```
Uočavamo da je minimum svih varijabli 0 lajkova, što je samo po sebi logično jer broj lajkova ne može biti negativan. Maksimume varijabli brojimo u desetinama i stotinama tisuća.

Kod varijable 'movie_facebook_likes' uočavamo da je barem 25% podataka jednako nuli. Prebrojimo koliko ih je točno jednako nuli.

```{r}
nrow(likesdata[likesdata$movie_facebook_likes == 0, ])
```

Dakle, 2083 (~43%) redaka u stupcu 'movie_facebook_likes' jednako je nuli. To je zaista velik udio podataka pa je za pretpostaviti da će distribucija biti desno zakrivljena, što nam dodatno potvrđuje i činjenica da je aritmetička sredina višestruko veća od medijana, vrijednosti od koje je točno polovica podataka manja. Štoviše, sredina je zamjetno veća i od trećeg kvartila, što bi značilo da su u gornjoj četvrtini podaci dovoljno veliki da bi 'nadvladali' ostatak. Drugim riječima, postoji nekolicina filmova sa zabilježenim iznimno velikim brojem lajkova s obzirom na većinu filmova. Moguće je da je riječ o grešci ili je neki film doživio ekstremnu popularnost među korisnicima Facebooka. Slična zapažanja mogu se primijeniti i na ostale varijable.

Interkvartilni rang i standardna devijacija su mjere raspršenosti podataka, no interkvartilni rang je za razliku od standardne devijacije neosjetljiv na ekstreme. Od svih promatranih varijabli, najviše odskače upravo varijabla 'movie_facebook_likes', koja u usporedbi s drugim varijablama ima osrednji rang, no zato ima najveću standardnu devijaciju, po čemu bismo mogli pretpostaviti da ima najviše stršećih vrijednosti.

Vizualizirajmo ponašanje promatranih varijabli korištenjem pravokutnog dijagrama.

```{r}
# Pravokutni dijagrami

boxplot(likesdata$movie_facebook_likes,
        main = 'Movie Facebook Likes Boxplot',
        ylab = 'Facebook Likes')

boxplot(likesdata$director_facebook_likes,
        main = 'Director Facebook Likes Boxplot',
        ylab = 'Facebook Likes')

boxplot(likesdata$actor_1_facebook_likes,
        main = 'Actor1 Facebook Likes Boxplot',
        ylab = 'Facebook Likes')

boxplot(likesdata$actor_2_facebook_likes,
        main = 'Actor2 Facebook Likes Boxplot',
        ylab = 'Facebook Likes')

boxplot(likesdata$actor_3_facebook_likes,
        main = 'Actor3 Facebook Likes Boxplot',
        ylab = 'Facebook Likes')

boxplot(likesdata$cast_total_facebook_likes,
        main = 'Cast Total Facebook Likes Boxplot',
        ylab = 'Facebook Likes')
```

Grafovi nam ne daju toliko informacija o ponašanju podataka jer je raspon stršećih vrijednosti prevelik da bi se dobro vidio ostatak distribucije, no grafom smo uspjeli potvrditi da varijabla 'movie_facebook_likes' doista ima najviše stršećih vrijednosti.

Nadalje, pogledajmo distribucije promatranih varijabli:

```{r}
# Histogrami

h = hist(likesdata$movie_facebook_likes,
         main="Movie Facebook Likes",
         xlab="Facebook Likes",
         ylab='Frequency',
         col="blue"
         )
abline(v = mean(likesdata$movie_facebook_likes, na.rm = TRUE), col = "red", lwd = 4)
abline(v = median(likesdata$movie_facebook_likes, na.rm = TRUE), col = "green", lwd = 4)

h = hist(likesdata$director_facebook_likes,
         main="Director Facebook Likes",
         xlab="Facebook Likes",
         ylab='Frequency',
         col="blue"
         )
abline(v = mean(likesdata$director_facebook_likes, na.rm = TRUE), col = "red", lwd = 4)
abline(v = median(likesdata$director_facebook_likes, na.rm = TRUE), col = "green", lwd = 4)

h = hist(likesdata$actor_1_facebook_likes,
         main="Actor1 Facebook Likes",
         xlab="Facebook Likes",
         ylab='Frequency',
         col="blue"
         )
abline(v = mean(likesdata$actor_1_facebook_likes, na.rm = TRUE), col = "red", lwd = 4)
abline(v = median(likesdata$actor_1_facebook_likes, na.rm = TRUE), col = "green", lwd = 4)

h = hist(likesdata$actor_2_facebook_likes,
         main="Actor2 Facebook Likes",
         xlab="Facebook Likes",
         ylab='Frequency',
         col="blue"
         )
abline(v = mean(likesdata$actor_2_facebook_likes, na.rm = TRUE), col = "red", lwd = 4)
abline(v = median(likesdata$actor_2_facebook_likes, na.rm = TRUE), col = "green", lwd = 4)

h = hist(likesdata$actor_3_facebook_likes,
         main="Actor3 Facebook Likes",
         xlab="Facebook Likes",
         ylab='Frequency',
         col="blue"
         )
abline(v = mean(likesdata$actor_3_facebook_likes, na.rm = TRUE), col = "red", lwd = 4)
abline(v = median(likesdata$actor_3_facebook_likes, na.rm = TRUE), col = "green", lwd = 4)

h = hist(likesdata$cast_total_facebook_likes,
         main="Cast Total Facebook Likes",
         xlab="Facebook Likes",
         ylab='Frequency',
         col="blue"
         )
abline(v = mean(likesdata$cast_total_facebook_likes, na.rm = TRUE), col = "red", lwd = 4)
abline(v = median(likesdata$cast_total_facebook_likes, na.rm = TRUE), col = "green", lwd = 4)
```

Baš kako smo i pretpostavili, distribucije varijabli su desno zakrivljene.

Sami histogrami nisu nam toliko korisni u ovom obliku jer se većina vrijednosti mjeri u stotinama, stoga skalirajmo podatke prirodnim logaritmom.

```{r}
# Histogrami (log)

h = hist(log(likesdata$movie_facebook_likes),
         axes = FALSE,
         main="Movie Facebook Likes (log)",
         xlab="Facebook Likes",
         ylab='Frequency',
         breaks = 20, col="blue"
         )
axis(side = 1,
     at = log(c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000)),
     labels = paste(c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000)),
     cex.axis = 0.75,
     padj = -1,
     hadj = 0.5,
     las = 1)
axis(2)

h = hist(log(likesdata$director_facebook_likes),
         axes = FALSE,
         main="Director Facebook Likes (log)",
         xlab="Facebook Likes",
         ylab='Frequency',
         breaks = 20, col="blue"
         )
axis(side = 1,
     at = log(c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000)),
     labels = paste(c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000)),
     cex.axis = 0.75,
     padj = -1,
     hadj = 0.5,
     las = 1)
axis(2)

h = hist(log(likesdata$actor_1_facebook_likes),
         axes = FALSE,
         main="Actor1 Facebook Likes (log)",
         xlab="Facebook Likes",
         ylab='Frequency',
         breaks = 20, col="blue"
         )
axis(side = 1,
     at = log(c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000)),
     labels = paste(c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000)),
     cex.axis = 0.75,
     padj = -1,
     hadj = 0.5,
     las = 1)
axis(2)

h = hist(log(likesdata$actor_2_facebook_likes),
         axes = FALSE,
         main="Actor2 Facebook Likes (log)",
         xlab="Facebook Likes",
         ylab='Frequency',
         breaks = 20, col="blue"
         )
axis(side = 1,
     at = log(c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000)),
     labels = paste(c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000)),
     cex.axis = 0.75,
     padj = -1,
     hadj = 0.5,
     las = 1)
axis(2)

h = hist(log(likesdata$actor_3_facebook_likes),
         axes = FALSE,
         main="Actor3 Facebook Likes (log)",
         xlab="Facebook Likes",
         ylab='Frequency',
         breaks = 20, col="blue"
         )
axis(side = 1,
     at = log(c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000)),
     labels = paste(c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000)),
     cex.axis = 0.75,
     padj = -1,
     hadj = 0.5,
     las = 1)
axis(2)

h = hist(log(likesdata$cast_total_facebook_likes),
         axes = FALSE,
         main="Cast Total Facebook Likes (log)",
         xlab="Facebook Likes",
         ylab='Frequency',
         breaks = 20, col="blue"
         )
axis(side = 1,
     at = log(c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000)),
     labels = paste(c(1, 5, 10, 50, 100, 500, 1000, 5000, 10000, 50000, 100000, 500000)),
     cex.axis = 0.75,
     padj = -1,
     hadj = 0.5,
     las = 1)
axis(2)
```

Ovi nam histogrami puno jasnije prikazuju distribucije promatranih varijabli. Distribucije su višemodalne. Većina ih ima najviše pojava u intervalu između 500 i 1000 lajkova te zatim oko 10 000 lajkova. Distribucija varijable 'director_facebook_likes' bila bi najbliža normalnoj distribuciji da nema stršećih vrijednosti koje se nakupljaju između vrijednosti 10 000 i 50 000 lajkova.


## Prosječni broj Facebook lajkova po žanru

Zanima nas kakva je prosječna raspodjela lajkova po žanrovima. Ideja je grupirati filmove po žanrovima i prema lajkovima filmova dobiti prosječan broj lajkova žanra. Kako jedan film može imati više žanrova, prvo ćemo ih morati razdvojiti.

```{r}
genres_edited %>% group_by(genres) %>% summarise(AVG_facebook_likes = round(mean(movie_facebook_likes))) -> genre_likes

par(mar=c(7.5, 4.1, 4.1, 2.1), font.axis = 2, font.lab =  2)
barplot(genre_likes$AVG_facebook_likes,
        names.arg = genre_likes$genres,
        main = 'Average No. of Facebook Likes by Genre',
        las = 2, col = 'blue')
```

Vidimo da je žanr s najvećim prosječnim brojem lajkova SF, dok dokumentarci u prosjeku dobivaju najmanje lajkova. Pogledajmo koji su točni iznosi:
```{r}
cat('Sci-Fi:', max(genre_likes$AVG_facebook_likes), '\n')
cat('Documentary:', min(genre_likes$AVG_facebook_likes), '\n')
```


## Jesu li povezani lajkovi lajkovi filma i lajkovi redatelja i glavnog glumca?

Pogledajmo postoji li povezanost između broja Facebook lajkova koje je dobio film i broja Facebook lajkova redatelja i glavnog glumca. Prvo ćemo izbaciti stršeće vrijednosti.

```{r}
# Outlieri

outliersgross <- boxplot(likesdata$movie_facebook_likes, plot=FALSE)$out
imdb1 <- likesdata[-which(likesdata$movie_facebook_likes %in% outliersgross),]

outliersgross <- boxplot(likesdata$gross, plot=FALSE)$out
imdb2 <- likesdata[-which(likesdata$gross %in% outliersgross),]

outliersbudget <- boxplot(imdb1$director_facebook_likes, plot=FALSE)$out
imdb11 <- imdb1[-which(imdb1$director_facebook_likes %in% outliersbudget),]

outliersdur <- boxplot(imdb2$actor_1_facebook_likes, plot=FALSE)$out
imdb22<- imdb2[-which(imdb2$actor_1_facebook_likes %in% outliersdur),]

```

```{r}

plot(imdb11$movie_facebook_likes,imdb11$director_facebook_likes) 

plot(imdb22$movie_facebook_likes,imdb22$actor_1_facebook_likes)

```

```{r}

fit.1 = lm(movie_facebook_likes~director_facebook_likes,data=imdb11) 

fit.2 = lm(movie_facebook_likes~actor_1_facebook_likes,data=imdb22)


plot(imdb11$director_facebook_likes,imdb11$movie_facebook_likes) 
lines(imdb11$director_facebook_likes,fit.1$fitted.values,col='red') 

plot(imdb22$actor_1_facebook_likes,imdb22$movie_facebook_likes)
lines(imdb22$actor_1_facebook_likes,fit.2$fitted.values,col='red')

```

Iz scatter plotova vidimo da povezanosti gotovo i nema. Napravit ćemo i kvantil-kvantil plotove kako bismo vidjeli razdiobu reziduala.

```{r}

selected.model = fit.1

qqnorm(rstandard(selected.model))
qqline(rstandard(selected.model))


selected.model = fit.2

qqnorm(rstandard(selected.model))
qqline(rstandard(selected.model))

```

Primjećujemo da razdiobe nisu niti blizu normalnoj.

Pogledajmo još mjere kvalitete prilagodbe modela podatcima.

```{r}

summary(fit.1)

summary(fit.2)

```

Obje vrijednosti R^2 su jako male što nam dodatno pokazuje koliko je mala povezanost između varijabli.


## Imaju li neki žanrovi značajno različite ocjene na IMDB-u?
Kod ove hipoteze zanima nas postoji li neka značajna razlika kod ocjena različitih žanrova na IMDB-u.
U nastavku ćemo testirati našu hipotezu. Promtoriti ćemo prosječne ocjene kod filmova koji pripadaju žanrovima "Biography" i "Horror".

```{r}
biography <- genres_edited[genres_edited$genres=="Biography",]
horror <- genres_edited[genres_edited$genres=="Horror",]

#Izdvajamo samo stupce sa zanrovima, imenima filmova i ocjenama
biography <- biography[c(10,12,25)]
horror <- horror[c(10,12,25)]

##Provjera postoje li filmovi koji su ujedno i Biography i Horror
biography.movie_titles <- biography["movie_title"]
horror.movie_titles <- horror["movie_title"]
remove.list <-Reduce(intersect, list(biography.movie_titles, horror.movie_titles))

cat("Broj filmova koji pripadju žanrovima \"Horror\" i \"Biography\": ", nrow(remove.list))
```
Vidimo da samo 1 film pripada u oba žanra te zbog pretpostavke nezavisnosti koju ćemo koristiti u našem testu odbaciti ćemo ovaj podatak.

```{r}
biography <- biography[!(biography$movie_title %in% remove.list), ]
horror <- horror[!(horror$movie_title %in% remove.list), ]
```

Sada kada smo dobili nezavisne podatke potrebno je provjeriti dolaze li podaci iz normalne razdiobe. Ovo ćemo napraviti uz pomoć QQ-plota.

```{r}
# QQ plot za ocjene zanra biography
qqnorm(biography$imdb_score, pch = 1, frame = FALSE,main='Ocjene zanra biography')
qqline(biography$imdb_score, col = "blue", lwd = 2)

# QQ plot za ocjene zanra horror
qqnorm(horror$imdb_score, pch = 1, frame = FALSE,main='Ocjene zanra horror')
qqline(horror$imdb_score, col = "blue", lwd = 2)

```
Iz QQ-plota možemo vidjeti kako ocjene za žanr "Horror" dolaze iz normalne razdiobe, no isto ne možemo reći i za žanr "Biography".
Pogledajmo imamo li veći broj stršećih vrijednosti koje utječu na ovaj rezultat

```{r}
boxplot(biography$imdb_score, horror$imdb_score,
        names=c("Biography IMDB score", "Horror IMDB score"),
        main = "Boxplot of IMDB scores")
```
Možemo vidjeti kako imamo dosta stršećih vrijednosti kod žanra "Biography" te ih zato uklanjamo kako bi dobili bolju pretpostavku normalnosti.

```{r}
biography.edited <- biography[!biography$imdb_score %in% boxplot.stats(biography$imdb_score)$out,]
```

Pogledajmo sada podatke na QQ-plotu.
```{r}
qqnorm(biography.edited$imdb_score, pch = 1, frame = FALSE,main='Ocjene zanra biography')
qqline(biography.edited$imdb_score, col = "blue", lwd = 2)
```

Sada kada smo postigli normalnost i nezavisnost ocjena za žanrove "Biography" i "Horror" možemo krenuti provoditi test.

$$1) \quad H_0 \quad \dots \quad  Prosječna \ ocjena \ žanra \ Biography \ je \ jednaka \ ocjeni \ žanra \ Horror $$ $$ \mu_1 = \mu_2 $$
$$2) \quad H_1 \quad \dots \quad  Prosječna \ ocjena \ žanra \ Biography \ nije \ jednaka \ ocjeni \ žanra \ Horror $$ $$ \mu_1 \neq \mu_2 $$
$$3) \quad \alpha = 0.05$$
Prije nego krenemo s provođenjem testa moramo provjeriti jesu li varijance naših podataka jednake kako bi znali provest odgovarajući t-test.
$$1) \quad H_0 \quad \dots \quad  Varijance \ distribucija \ se \ ne \ razlikuju$$ $$ \sigma_1 = \sigma_2$$
$$2) \quad H_1 \quad \dots \quad  Varijance \ distribucija \ se \ razlikuju$$ $$ \sigma_1 \neq \sigma_2$$
$$3) \quad \alpha = 0.05$$
```{r}
var.test(biography$imdb_score, horror$imdb_score)
```
Zbog jako male p-vrijednosti zaključujemo da na razini značajnosti od 5% varijance nisu jednake. Nakon toga provodimo t-test za za različite varijance. 

```{r}
t.test(biography.edited$imdb_score, horror$imdb_score, alt = "two.sided", var.equal = FALSE)
```
Možemo vidjeti kako je p-vrijednost izrazito mala te iz tog razloga odbacujemo hipotezu $H_0$ u korist $H_1$ te zaključujemo da na razini značajnosti od 5% sredine ocjena za žanrove "Biography" i "Horror" nisu jednake. 

Pogledajmo sada usporedbu 5 žanrova (Action, Comedy, Drama, Thriller, Romance) i njihovih prosječnih ocjena korištenjem ANOVE. Izabrali smo upravo ove žanrove zbog veličine njihvog uzorka (n > 1000) što naravno utječe na ispravnost naših zaključaka i smanjuje šanse za pogreške prve i druge vrste.
Imamo problem jer podaci iz uzoraka nisu nezavisni te je zato potrebno gledati samo filmove koji ne pripadaju nijednom od ostalih 4 žanrova.

Kao što smo vidjeli u deskriptivnoj analizi postoji velik broj stršećih vrijednosti što može znatno utjecati na pretpostavku normalnosti podataka koja nam je potrebna.
Izbacimo prvo stršeće vrijednosti iz skupa podataka za pojedine žanrove
```{r}
#Svi filmovi pojedinog zanra
action <- genres_edited[genres_edited$genres=="Action",]
comedy <- genres_edited[genres_edited$genres=="Comedy",]
drama <- genres_edited[genres_edited$genres=="Drama",]
thriller <- genres_edited[genres_edited$genres=="Thriller",]
romance <- genres_edited[genres_edited$genres=="Romance",]

#Izbacivanje strsecih vrijednosti
action <- action[!action$imdb_score %in% boxplot.stats(action$imdb_score)$out,]
comedy <- comedy[!comedy$imdb_score %in% boxplot.stats(comedy$imdb_score)$out,]
drama <- drama[!drama$imdb_score %in% boxplot.stats(drama$imdb_score)$out,]
thriller <- thriller[!thriller$imdb_score %in% boxplot.stats(thriller$imdb_score)$out,]
romance <- romance[!romance$imdb_score %in% boxplot.stats(romance$imdb_score)$out,]

```

Izbacimo nakon toga filmove koji pripadaju u više žanrova iz našeg skupa.

```{r}
#Imena filmova pojedinog zanra (da lakse maknemo filmove koji pripadaju vise zanrova)
action.movie_title <- action["movie_title"]
comedy.movie_title <- comedy["movie_title"]
drama.movie_title <- drama["movie_title"]
thriller.movie_title <- thriller["movie_title"]
romance.movie_title <- romance["movie_title"]

#Liste filmova drugih zanrova (ako je ime filma u toj listi onda pripada vise zanrova)
action.remove_list <- Reduce(union,list(comedy.movie_title, drama.movie_title, thriller.movie_title, romance.movie_title))
comedy.remove_list <- Reduce(union, list(action.movie_title, drama.movie_title, thriller.movie_title, romance.movie_title))
drama.remove_list <- Reduce(union, list(action.movie_title, comedy.movie_title, thriller.movie_title, romance.movie_title))
thriller.remove_list <- Reduce(union, list(action.movie_title, drama.movie_title, comedy.movie_title, romance.movie_title))
romance.remove_list <- Reduce(union, list(action.movie_title, drama.movie_title, thriller.movie_title, comedy.movie_title))

#Micanje svih filmova iz drugih zanrova iz skupa podataka

action.nez <- action[!(action$movie_title %in% action.remove_list$movie_title), ]
comedy.nez <- comedy[!(comedy$movie_title %in% comedy.remove_list$movie_title), ]
drama.nez <- drama[!(drama$movie_title %in% drama.remove_list$movie_title),]
thriller.nez <- thriller[!(thriller$movie_title %in% thriller.remove_list$movie_title), ]
romance.nez <- romance[!(romance$movie_title %in% romance.remove_list$movie_title),]
```
Nakon transformacija dobili smo filmove koji pripadaju samo jednom žanru, a ne nijednom od ostalih četiri.
Pogledajmo sada koliko je filmova ostalo koji ne pripadaju ni jednom drugom žanru.

``` {r}
nrow(action.nez)
nrow(comedy.nez)
nrow(drama.nez)
nrow(thriller.nez)
nrow(romance.nez)
```
Vidimo kako je broj filmova žanra "Romance" dosta manji od ostalih, međutim takvo ponašanje je očekivano s obzirom da većina filmova ovog žanra spada ili u žanr "Comedy" ili žanr "Drama".
Sada kada smo postigli nezavisnost podataka moramo provjerit normalnost. To ćemo napraviti uz pomoć Lillieforsove inačice KS testa.

``` {r}
require(nortest)

lillie.test(action.nez$imdb_score)
lillie.test(comedy.nez$imdb_score)
lillie.test(drama.nez$imdb_score)
lillie.test(thriller.nez$imdb_score)
lillie.test(romance.nez$imdb_score)

```
Možemo vidjeti kako žanr "Drama" ima jako malu p-vrijednost pa za njega ne možemo pretpostaviti normalnost. Za ostale žanrove na razini značajnosti od 1% vrijedi pretpostavka normalnosti.
U daljnoj provedbi testa izbacujemo žanr "Drama" iz analize zbog nezadovoljenih pretpostavki testa.
Sljedeća pretpostavka koja nam je potrebna za analizu je homogenost varijanci svih uzoraka. To ćemo provjeriti uz pomoć Bartlettovog testa koji će zbog prijašnje pretpostavke normalnosti još bolje prikazati rezultate.

``` {r}
# Pojedinacne varijance svakog zanra
var(action.nez$imdb_score)
var(comedy.nez$imdb_score)
var(thriller.nez$imdb_score)
var(romance.nez$imdb_score)

# Dodajemo listu ocjena u varijable
a <- action.nez$imdb_score
b <- comedy.nez$imdb_score
c <- thriller.nez$imdb_score
d <- romance.nez$imdb_score

bartlett.test(list(a,b,c,d))

```
Vidimo kako Bartlettov test daje p-vrijednost od nešto više od 8% što nam, na razini značajnosti od 1%, dozvoljava da pretpostavimo da su varijance ova 4 žanra jednake.
Nakon što smo zadovoljili pretpostavke normalnosti, nezavisnosti i homogenosti varijanci uzorka možemo provesti ANOVU sa sljedećim hipotezama: 
$$ \begin{aligned}
  H_0 & : \mu_1 = \mu_2 = \mu_3 = \mu_4 \\
  H_1 & : \neg H_0.
\end{aligned} $$

``` {r}
# Sve filmove dodajemo u jednu listu
allNames <- c(action.nez$movie_title, comedy.nez$movie_title)
allNames <- c(allNames, romance.nez$movie_title)
allNames <- c(allNames, thriller.nez$movie_title)
allGenres <- c("Action", "Comedy", "Thriller", "Romance")
#Editamo pocetni skup
edited <- genres_edited[genres_edited$movie_title %in% allNames,]
edited <- edited[edited$genres %in% allGenres,]
#Provedba ANOVE
test <- aov(imdb_score ~ genres, data=edited)
summary(test)
```
Vidimo da je p-vrijednost jako mala te na razini značajnosti od 1% odbacujemo nultu hipotezu i zaključujemo da srednje vrijednosti ocjena za barem dva žanra od žanrova "Action", "Comedy", "Thriller", "Romance" nisu jednake.
Tako se naša inicijalna pretpostavka o uniformnoj distribuciji srednjih vrijednosti ocjena pokazala netočnom te zaključujemo da postoji značajna razlika u prosječnim ocjenama pojedinih žanrova.


## Dobivaju li američki filmovi veća financiranja od filmova drugih zemalja


Prebrojimo koliko Američkih filmova za svoj budget ima NA.
```{r}
americkiFilmovi <- imdb[imdb$country == "USA",]$budget/1000000

cat("Broj Americkih filmova : ", length(americkiFilmovi), "\n")
cat("Broj NA vrijednosti: ", sum(is.na(americkiFilmovi)), "\n")

```
Vidimo da je manje od 20% te cemo te redke sada maknuti.
```{r}
americkiFilmovi <- na.omit(americkiFilmovi)
cat("Broj Americkih filmova bez NA redaka: ", length(americkiFilmovi), "\n")
```

```{r}
neAmerickiFilmovi <- imdb[imdb$country != "USA" ,]$budget/1000000

cat("Broj ne Americkih filmova : ", length(neAmerickiFilmovi), "\n")
cat("Broj NA vrijednosti: ", sum(is.na(neAmerickiFilmovi)), "\n")

```
Ovdje je takoder tih redaka manje od 20% te cemo te redke takoder sada maknuti.

```{r}
neAmerickiFilmovi <- na.omit(neAmerickiFilmovi)
cat("Broj Ne Americkih filmova bez NA redaka: ", length(neAmerickiFilmovi), "\n")
```
Maknimo sada outliere iz vektora.

```{r}
americkiFilmoviOutliers <- boxplot(americkiFilmovi, plot=FALSE)$out
americkiFilmovi <- americkiFilmovi[-which(americkiFilmovi %in% americkiFilmoviOutliers)]


neAmerickiFilmoviOutliers <- boxplot(neAmerickiFilmovi, plot=FALSE)$out
neAmerickiFilmovi <- neAmerickiFilmovi[-which(neAmerickiFilmovi %in% neAmerickiFilmoviOutliers)]


```

Sada ćemo vizualizirati te podatke da vidimo dolaze li iz normalne razdiobe.
```{r}

qqnorm(americkiFilmovi, pch = 1, frame = FALSE,main='Financiranje Americkih filmova ')
qqline(americkiFilmovi, col = "blue", lwd = 2)


```
```{r}

qqnorm(neAmerickiFilmovi, pch = 1, frame = FALSE,main='Financiranje Ne Americkih filmova ')
qqline(neAmerickiFilmovi, col = "blue", lwd = 2)

```
Vidimo da ove grafovi ne nalikuju na Normalnu razdiobu, no mozda će nalikovati ako na podatke primjenimo logaritamsku funkciju.

```{r}
logAmericki <- log(americkiFilmovi)

qqnorm(logAmericki, pch = 1, frame = FALSE,main='Financiranje Americkih filmova sa log funkcijom')
qqline(logAmericki, col = "blue", lwd = 2)


```

```{r}

logNeAmericki <- log(neAmerickiFilmovi)

qqnorm(logNeAmericki, pch = 1, frame = FALSE,main='Financiranje Ne Americkih filmova sa log funkcijom')
qqline(logNeAmericki, col = "blue", lwd = 2)

```


Vidimo da ni nakon toga ne nalikuju na normalnu, ali ako bolje proučimo, graf nalikuje na x^3, te ako primjenimo treci korijen, možda će onda podatci biti normalni.

```{r}
treciKorijenAmericki <- americkiFilmovi ^ (1/3)

qqnorm(treciKorijenAmericki, pch = 1, frame = FALSE,main='Financiranje Americkih filmova sa treci korijen funkcijom')
qqline(treciKorijenAmericki, col = "blue", lwd = 2)


```

```{r}

treciKorijenNeAmericki <- neAmerickiFilmovi ^ (1/3)

qqnorm(treciKorijenNeAmericki, pch = 1, frame = FALSE,main='Financiranje Ne Americkih filmova sa treci korijen funkcijom')
qqline(treciKorijenNeAmericki, col = "blue", lwd = 2)

```


Pogledajmo sada i histograme za te novoskalirane podatke.

```{r}

hist(treciKorijenAmericki,
        main="Histogram Američkih filmova skaliranih funkcijom 3. korijen",
        xlab="budžet u milijunima",
        ylab="frekvencija"
     )


hist(treciKorijenNeAmericki,
        main="Histogram Američkih filmova filmova skaliranih funkcijom 3. korijen",
        xlab="budžet u milijunima",
        ylab="frekvencija"
     )

```
Iz grafova vidimo da su distribucije sada poprilično normalne.


```{r}
boxplot(treciKorijenAmericki, treciKorijenNeAmericki,
        main="Box plot Američih i ne Američkih filmova skaliranih funkcijom 3. korijen",
        xlab="filmovi",
        ylab="budžet u milijunima"
        )
```






```{r}
cat("Srednja vrijednost Američkih Filmova: ", mean(treciKorijenAmericki), "\n")
cat("Srednja vrijednost ne Američkih Filmova: ", mean(treciKorijenNeAmericki), "\n")

cat("Standardna devijacija Američkih Filmova: ", sd(treciKorijenAmericki), "\n")
cat("Standardna devijacija ne Američkih Filmova: ", sd(treciKorijenNeAmericki), "\n")

```
Sada cemo provesti i F test za varijance.

```{r}

var.test(treciKorijenAmericki,treciKorijenNeAmericki)

```
Iz njega vidimo da je p value skoro pa i 0 te iz toga zaključujemo da se varijance uistinu razlikuju

Sada postavimo hipoteze, H0... Američki filmovi imaju jednak budzet kao i ne Američki -> mi1 = mi2, d0 = 0
                         H1... Američki filmovi imaju veci budzet -> mi1 > mi2, d0 > 0
                         alfa = 5%
```{r}

t.test(treciKorijenAmericki, treciKorijenNeAmericki, alternative = "greater", var.equal = FALSE)

```
Hipoteza H0 se odbija jer je p vrijednost manja od alfe.

Iz ovog mozemo zaključiti da Americki filmovi imaju veci budežet od ne Američkih filmova, no ovo je bila provjera svih ne Američkih zajedno.

Idemo sada ponoviti isti postupak ali za neku zemlje zasebno, poput UK, izbacimo outliere, te prazne vrijednosti, te skaliramo sa funkcijom 3. korijen.

```{r}
UKfilmovi <- imdb[imdb$country == "UK",]$budget/1000000

UKfilmovi <- na.omit(UKfilmovi)

UKfilmoviOutliers <- boxplot(UKfilmovi, plot=FALSE)$out
UKfilmovi <- UKfilmovi[-which(UKfilmovi %in% UKfilmoviOutliers)]


UKfilmovi <- UKfilmovi ^ (1/3)

qqnorm(UKfilmovi, pch = 1, frame = FALSE,main='Financiranje UK filmova sa treci korijen funkcijom')
qqline(UKfilmovi, col = "blue", lwd = 2)

```
Iz grafa mozemo zaključiti normalnost.

```{r}
cat("Srednja vrijednost UK Filmova: ", mean(UKfilmovi), "\n")
cat("Standardna devijacija UK Filmova: ", sd(UKfilmovi), "\n")
```
One sliče na vrijednosti koje smo dobili za sve ne americke filmove zajedno, no idemo provesti f test jos jednom za svaki slučaj.

```{r}

var.test(treciKorijenAmericki,UKfilmovi)

```
Kao što vidimo, opet možemo zaključiti da varijance nisu jednake jer je p vrijednost opet skoro pa jednaka nuli
Sada postavimo hipoteze, H0... Američki filmovi imaju jednak budžet kao i UK filmovi -> mi1 = mi2, d0 = 0
                         H1... Američki filmovi imaju veci budžet -> mi1 > mi2, d0 > 0
                         alfa = 5%
```{r}

t.test(treciKorijenAmericki, UKfilmovi, alternative = "greater", var.equal = FALSE)

```
p vrijednost je i u ovom testu značajno manja od alfe te zaključujemo da Američki filmovi dobivaju veći budžet od UK filmova


## Možemo li temeljem danih varijabli predvidjeti zaradu filmova? 
Trebamo provjeriti postoji li veza između ulaznih varijabli (regresora) i izlazne varijable (reakcije) koja je u našem slučaju zarada(gross) filma.
Za to ćemo koristiti linearnu regresiju. Želimo saznati koliko su te veze jake, koje ulazne varijable najviše utječu na zaradu, te vidjeti možemo li predvidjeti zaradu na temelju nekih ulaznih varijabli i s kojom točnošću.
Tražimo sve varijable koje bi mogle utjecati na zaradu filma, prvo bez uklanjanja NA vrijednosti i stršečih vrijendosti.
Zarada je prikazana u milijunima dolara.
Moramom uzeti u obzir da nisu sve varijable poznate pri izlasku novog filma.
Prvo ćemo ispitati utjecaj sljedećih varijabli:
- budžet (budget)
- trajanje filma (duration)
- godina izlaska filma (title_year)


```{r}

plot(imdb$budget,imdb$gross/1000000) 


plot(imdb$duration,imdb$gross/1000000)


plot(imdb$title_year,imdb$gross/1000000)


```
Utjecaj svake od varijabli na zaradu prikazali smo pomoću scatter plot-a.
Vidimo da u dosta slučajeva postoje stršeće vrijednosti i NA vrijednosti zbog kojih je teže jasno vidjeti odnos varijabli.
Radi preglednosti ukloniti ćemo NA vrijednosti i ponoviti postupak.


```{r}

imdb0 <- imdb[!is.na(imdb$gross),]
imdb1 <- imdb0[!is.na(imdb0$budget),]
imdb2 <- imdb0[!is.na(imdb0$duration),]
imdb3 <- imdb0[!is.na(imdb0$title_year),]


```

```{r scatter plots 2}

plot(imdb1$budget,imdb1$gross/1000000) 


plot(imdb2$duration,imdb2$gross/1000000)


plot(imdb3$title_year,imdb3$gross/1000000)


```
Pošto ne vidimo preveliku promjenu, ukloniti ćemo i stršeće vrijednosti.

```{r}


outliersgross <- boxplot(imdb1$gross, plot=FALSE)$out
imdbh1 <- imdb1[-which(imdb1$gross %in% outliersgross),]

outliersgross <- boxplot(imdb2$gross, plot=FALSE)$out
imdbh2 <- imdb2[-which(imdb2$gross %in% outliersgross),]

outliersgross <- boxplot(imdb3$gross, plot=FALSE)$out
imdbh3 <- imdb3[-which(imdb3$gross %in% outliersgross),]

outliersbudget <- boxplot(imdbh1$budget, plot=FALSE)$out
imdb11 <- imdbh1[-which(imdbh1$budget %in% outliersbudget),]

outliersdur <- boxplot(imdbh2$duration, plot=FALSE)$out
imdb22<- imdbh2[-which(imdbh2$duration %in% outliersdur),]

outliersty <- boxplot(imdbh3$title_year, plot=FALSE)$out
imdb33 <- imdbh3[-which(imdbh3$title_year %in% outliersty),]

```


```{r scatter plots}

plot(imdb11$budget,imdb11$gross/1000000) 


plot(imdb22$duration,imdb22$gross/1000000)


plot(imdb33$title_year,imdb33$gross/1000000)


```
Primjećujemo da niti jedna od ulaznih varijabli nema jako veliku povezanost, ali npr. budget pokazuje određenu povezanost.

Sada ćemo na dijagrame dodati pravce linearne regresije kako bismo bolje vidjeli efekte varijabli na zaradu.


```{r jednostavna regresija}

fit.budget = lm(gross~budget,data=imdb11) 

fit.dur = lm(gross~duration,data=imdb22)


fit.ty = lm(gross~title_year,data=imdb33)


plot(imdb11$budget,imdb11$gross) 
lines(imdb11$budget,fit.budget$fitted.values,col='red') 

plot(imdb22$duration,imdb22$gross)
lines(imdb22$duration,fit.dur$fitted.values,col='red')


plot(imdb33$title_year,imdb33$gross)
lines(imdb33$title_year,fit.ty$fitted.values,col='red')


```
Sada bolje vidimo utjecaje na zaradu, budget ima najveći utjecaj što vidimo po nagibu pravca linearne regresije.

Sada ćemo provjeriti normalnost reziduala za svaki model pomoću kvantil-kvantil plota.


```{r}

selected.model = fit.budget

qqnorm(rstandard(selected.model))
qqline(rstandard(selected.model))


selected.model = fit.dur

qqnorm(rstandard(selected.model))
qqline(rstandard(selected.model))


selected.model = fit.ty

qqnorm(rstandard(selected.model))
qqline(rstandard(selected.model))


```

Distribucije donekle nalikuju na normalnu razdiobu, ali sve bi ih trebalo još više približiti normalnoj razdiobi ako želimo pretpostaviti normalnost reziduala.
Pokušat ćemo to riješiti kasnije doadvanjem drugih varijabli u model te dodavanjem interakcijskih ili polinomijalnih članova.

Pogledat ćemo mjere kvalitete prilagodbe modela podatcima.

```{r analiza procijenjenih modela}

summary(fit.budget)

summary(fit.dur)

summary(fit.ty)


```

Za svaki od modela možemo vidjeti intercept i slope, pomoću koji možemo procijeniti zaradu za bilo koju vrijednost ulazne varijable.


Primjećujemo da nisu svi modeli jednako kvalitetni. Vidimo da najveći utjecaj ima budget kao što smo i pretpostavili prije, to se očituje najvećim vrijednostima R^2. Vidimo da duration nema utjecaj kao budget ali ima određen značaj, dok za title_year vidimo da nema gotovo nikakav utjecaj (R^2 je skoro 0). 

Pogledajmo i Pearsonov keoficijent korelacije za sljedeće 3 varijable:

```{r korelacijski koeficijent}


cor(imdb11$budget,imdb11$gross)

cor(imdb22$duration,imdb22$gross)

cor(imdb33$title_year,imdb33$gross)
```
On dodatno potvrđuje veći utjecaj nekih varijabli.


Sada ćemo napraviti procjenu modela višestruke regresije. Prije procjene modela višestruke regresije moramo provjeriti da nam varijable nisu međusobno previše korelirane.

```{r cor}

imdbcor <- imdb[!is.na(imdb$gross),]
imdbcor <- imdbcor[!is.na(imdbcor$budget),]
imdbcor <- imdbcor[!is.na(imdbcor$duration),]
imdbcor <- imdbcor[!is.na(imdbcor$title_year),]

cor(cbind(imdbcor$budget,imdbcor$duration,imdbcor$title_year)) 

```
Vidimo da nam varijable nisu previše korelirane i možemo procijeniti model.

```{r visestruka regresija}
fit.multi = lm(gross ~ budget + duration + title_year, imdb11)
summary(fit.multi)

```
Vidimo da nam ovaj model nije mnogo bolji nego onaj koji sadrži samo buget. Zato ćemo radi jednostavnosti nastaviti s modelom koji sadrži samo budget.

Sada ćemo probati poboljšati model dodavajući kategorijske varijable.
Kategorijske varijable koje ćemo uzeti u obzir su:
- color
- language
- country
- content_rating
- aspect_ratio

```{r}

fit.multi.1 = lm(gross ~ budget + country , imdb11)
summary(fit.multi.1)



```

Dodavanjem varijable country model nam se poboljšava, ali u stupcu country se pojavljuje jako puno država, što bi nam zakompliciralo model, a i unos podataka pri procjeni zarade za novi film.
Pogledajmo koje sve vrijednosti može poprimiti stupac country.

```{r}
table(imdb11['country'])
```
Vidimo da ima uvjerljivo najviše američkih filmova, zato ćemo zbog jednostavnosti zamijeniti sve ostale države s OtherCountry.

```{r}
imdbcou = imdb11
imdbcou$country[imdbcou$country!="USA"]<-"OtherCountry"
table(imdbcou['country'])
```
Nakon zamjene isprobajmo novi model:

```{r}

fit.multi.2 = lm(gross ~ budget + country, imdbcou)
summary(fit.multi.2)



```
Model je gotovo jednako dobar što možemo vidjeti po ako usporedimo vrijednosti Adjusted R-squared (prije 0.2677, sada 0.2667).

Isprobajmo sada dodati još neke kategorijske varijable u naš model.



```{r}

fit.multi.3 = lm(gross ~ budget + country + color, imdbcou)
summary(fit.multi.3)

```
Dodavanjem varijable color nismo znatno poboljšali model, zato ćemo odbaciti color.

Prije dodavanja varijable language u model, pogledajmo koje sve vrijednosti postoje u tom stupcu.

```{r}
table(imdbcou['language'])
```
Engleski je očekivano najčešći jezik, zato ćemo sve ostale zamijeniti s OtherLanguage.

```{r}
imdblan = imdbcou
imdblan$language[imdblan$language!="English"]<-"OtherLanguage"
table(imdblan['language'])
```
```{r}

fit.multi.lan = lm(gross ~ budget + country + language, imdblan)
summary(fit.multi.lan)

```
Ponovno ne vidimo bitno poboljšanje u modelu, ponovit ćemo postupak za ostale kategorijske varijable, kako bismo pronašli najbolji model.

```{r}
table(imdbcou['content_rating'])
```
Mijenjamo sve vrijednosti osim PG, PG-13 i R u OtherRating.

```{r}
imdbcr = imdblan
imdbcr$content_rating[imdbcr$content_rating!="R" & imdbcr$content_rating!="PG-13" & imdbcr$content_rating!="PG"]<-"OtherRating"
table(imdbcr['content_rating'])
```
```{r}

fit.multi.cr = lm(gross ~ budget + country + content_rating, imdbcr)
summary(fit.multi.cr)

```
Niti dodavanje content_rating-a nam značajno ne poboljšava model.

```{r}
table(imdbcr['aspect_ratio'])
```
Zamijenimo sve vrijednosti aspect_ratio osim 1.85 i 2.35 s OtherRatio.

```{r}
imdbar = imdbcr
imdbar$aspect_ratio[imdbar$aspect_ratio!="1.85" & imdbar$aspect_ratio!="2.35"]<-"OtherRatio"
table(imdbar['aspect_ratio'])
```
```{r}

fit.multi.ar = lm(gross ~ budget + country + aspect_ratio, imdbar)
summary(fit.multi.ar)

```
Niti ovaj model nije bolji od modela koji samo sadrži budget i country.

Sada ćemo još pokušati transformirati neke varijable i približiti distribuciju reziduala normalnoj distribuciji.

```{r}
library("SciViews")
fit.multi.exp = lm(gross ~ budget + country + I(budget^(1/3)), imdbcou)
summary(fit.multi.exp)



```
Primijenili smo transformaciju I(budget^(1/3)) i time smo malo poboljšali model.
Pogledajmo sada distribuciju reziduala.

```{r}
selected.model = fit.multi.exp
hist((selected.model$residuals))
hist(rstandard(selected.model))
qqnorm(rstandard(selected.model))
qqline(rstandard(selected.model))
```
Uklonit ćemo još stršećih vrijednosti kako bismo distribuciju reziduala još više približili normalnoj-



```{r}
nrow(imdbar)
outliers00 <- boxplot(imdbar$gross, plot=FALSE)$out
imdbtry <- imdbar[-which(imdbar$gross %in% outliers00),]

outliers01 <- boxplot(imdbtry$budget, plot=FALSE)$out
imdbtry <- imdbtry[-which(imdbtry$budget %in% outliers01),]

outliers02 <- boxplot(imdbtry$gross, plot=FALSE)$out
imdbtry <- imdbtry[-which(imdbtry$gross %in% outliers02),]

outliers03 <- boxplot(imdbtry$budget, plot=FALSE)$out
imdbtry <- imdbtry[-which(imdbtry$budget %in% outliers03),]

outliers04 <- boxplot(imdbtry$gross, plot=FALSE)$out
imdbtry <- imdbtry[-which(imdbtry$gross %in% outliers04),]

outliers05 <- boxplot(imdbtry$gross, plot=FALSE)$out
imdbtry <- imdbtry[-which(imdbtry$gross %in% outliers05),]

outliers06 <- boxplot(imdbtry$gross, plot=FALSE)$out
imdbtry <- imdbtry[-which(imdbtry$gross %in% outliers06),]

outliers07 <- boxplot(imdbtry$gross, plot=FALSE)$out
imdbtry <- imdbtry[-which(imdbtry$gross %in% outliers07),]

nrow(imdbtry)

fit.multi.x = lm(gross ~ budget + country + I(budget^(1/3)), imdbtry)
summary(fit.multi.x)

selected.model = fit.multi.x
hist((selected.model$residuals))
hist(rstandard(selected.model))
qqnorm(rstandard(selected.model))
qqline(rstandard(selected.model))



```
Sada je distribucija nešto bliža normalnoj.

Pogledajmo sada naš model.

```{r}

fit.multi.x = lm(gross ~ budget + country + I(budget^(1/3)), imdbtry)
summary(fit.multi.x)

```
Na temelju ovog modela pokušat ćemo predvidjeti zaradu novog filma.
Naš model sadržava relevantne varijable koje objašnjavaju oko 26% varijance zarade filma. 
Predviđanjem zarade novog filma vidjet je li tih 26% "dovoljna" vrijednost R^2.

Pošto je ovo stariji dataset, nekih filmova koji su u međuvremenu izašli nema (zadnja godina je 2016), pa na njima možemo ocijeniti model, ali isprobati ćemo i za neke filmove koji nisu ni sada izašli.

1)No time to die

```{r}

input_var <- data.frame(budget = 300000000, country = "USA") 
linear_model = fit.multi.x
predict(linear_model, newdata = input_var,interval = "confidence")
```
Rezultat koji smo dobili je interval pouzdanosti (95%) i fit predviđena vrijednost.
Film No time to die je zaradio oko 500 milijuna dolara, što niti blizu ne pada u naš interval pouzdanosti.

Isprobajmo sad s filmom koji ima manji budget.

2) Nobody

```{r}

input_var <- data.frame(budget = 16000000, country = "USA") 
linear_model = fit.multi.x
predict(linear_model, newdata = input_var,interval = "confidence")
```
Nobody je zapravo zaradio oko 40 milijuna, što opet nije blizu našoj procjeni.

Pokušat ćemo sada s filmom koji nije američki.

3) The Battle at Lake Changjin

Ovo je kineski film s dosta velikim budžetom.

```{r}

input_var <- data.frame(budget = 200000000, country = "OtherCountry") 
linear_model = fit.multi.x
predict(linear_model, newdata = input_var,interval = "confidence")
```
Prava zarada filma je oko 700-800 milijuna, naš model je opet puno pogriješio.

Sada ćemo probati još probati predvidjeti zaradu nekih filmova koji još nisu izašli.

4) The Batman

```{r}

input_var <- data.frame(budget = 100000000, country = "USA") 
linear_model = fit.multi.x
predict(linear_model, newdata = input_var,interval = "confidence")
```

5) Spiderman: Across the Spiderverse

```{r}

input_var <- data.frame(budget = 90000000, country = "USA") 
linear_model = fit.multi.x
predict(linear_model, newdata = input_var,interval = "confidence")
```
Zaključujemo da naš model nije dobar za kvalitetnu procjenu zarade novog filma, trebao bi nam model s većim R^2. Takav bolji model bismo dobili dodavanjem varijabli koje više utječu na zaradu, a te varijable nam često nisu dostupne prije samog izlaska filma ili su prekomplicirane za napraviti model s njima (npr glumci u filmu sigurno imaju veliki utjecaj na zaradu ali pošto ima jako puno glumaca, teže je napraviti model). Osim toga treba uzeti u obzir da na zaradu utječu i druge varijable osim ovih koje su prikazane u ovom datasetu.